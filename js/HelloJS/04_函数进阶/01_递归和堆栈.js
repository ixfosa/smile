

// -------------------------------------------------------------------------------------------
// 递归和堆栈

    // 当一个函数解决一个任务时，在解决的过程中它可以调用很多其它函数。在部分情况下，
    // 函数会调用 自身。这就是所谓的 递归。

// 两种思考方式


// 简单起见，让我们写一个函数 pow(x, n)，它可以计算 x 的 n 次方。换句话说就是，x 乘以自身 n 次。

//- pow(2, 2) = 4
//- pow(2, 3) = 8
//- pow(2, 4) = 16

// 有两种实现方式。

// 1. 迭代思路：使用 for 循环：
function pow1(x, n) {
    let res = 1;
    for (let i = 0; i < n; i++) {
        res *= x;
    }
    return res;
}
console.log( pow1(2, 3) ); // 8


// 2. 递归思路：简化任务，调用自身：
function pow2(x, n) {
    if (n == 1) {
        return x;
    } else {
        return x * pow2(x, n-1)
    }
    // return (n == 1) ? x : (x * pow(x, n - 1));
}
console.log( pow2(2, 3) ); // 8

/*
    当 pow(x, n) 被调用时，执行分为两个分支：

                    if n==1  = x
                    /
        pow(x, n) =
                    \
                    else     = x * pow(x, n - 1)

1. 如果 n == 1，所有事情都会很简单，这叫做 基础 的递归，因为它会立即产生明显的结果：pow(x, 1) 等于 x。
2. 否则，我们可以用 x * pow(x, n - 1) 表示 pow(x, n)。在数学里，可能会写为 xn = x * xn-1。
   这叫做 一个递归步骤：我们将任务转化为更简单的行为（x 的乘法）和更简单的同类任务的调用
   （带有更小的 n 的 pow 运算）。接下来的步骤将其进一步简化，直到 n 达到 1。

可以说 pow 递归地调用自身 直到 n == 1。

*/




// -------------------------------------------------------------------------------------------




// 执行上下文和堆栈

    // 有关正在运行的函数的执行过程的相关信息被存储在其 执行上下文 中。

    // 执行上下文 是一个内部数据结构，它包含有关函数执行时的详细细节：
        // 当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。

    // 一个函数调用仅具有一个与其相关联的执行上下文。

    //- 当一个函数进行嵌套调用时，将发生以下的事儿：
        //- 当前函数被暂停；
        //- 与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；
        //- 执行嵌套调用；
        //- 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从停止的位置恢复外部函数。

// 让我们看看 pow(2, 3) 调用期间都发生了什么。

// 在调用 pow(2, 3) 的开始，执行上下文（context）会存储变量：x = 2, n = 3，执行流程在函数的第 1 行。

// 我们将其描绘如下：
/*
    Context: { x: 2, n: 3, at line 1 } call pow(2, 3)

    这是函数开始执行的时候。条件 n == 1 结果为假，所以执行流程进入 if 的第二分支。

    1    function pow(x, n) {
    2        if (n == 1) {
    3           return x;
    4        } else {
    5            return x * pow(x, n - 1);
    6        }
    7    }
    consloe.log( pow(2, 3) );

    变量相同，但是行改变了，因此现在的上下文是：
    Context: { x: 2, n: 3, at line 5 } call pow(2, 3)

    为了计算 x * pow(x, n - 1)，我们需要使用带有新参数的新的 pow 子调用 pow(2, 2)。

    pow（2, 2)
    为了执行嵌套调用，JavaScript 会在 执行上下文堆栈 中记住当前的执行上下文。

    这里我们调用相同的函数 pow，但这绝对没问题。所有函数的处理都是一样的：
        1. 当前上下文被“记录”在堆栈的顶部。
        2. 为子调用创建新的上下文。
        3. 当子调用结束后 —— 前一个上下文被从堆栈中弹出，并继续执行。

    下面是进入子调用 pow(2, 2) 时的上下文堆栈：
        Context: { x: 2, n: 2, at line 1 } call pow(2, 2)
        Context: { x: 2, n: 3, at line 5 } call pow(2, 3)

    新的当前执行上下文位于顶部（粗体显示），之前记住的上下文位于下方。

    当我们完成子调用后 —— 很容易恢复上一个上下文，因为它既保留了变量，也保留了当时所在代码的确切位置。

    请注意：
    我们使用“行（line）”一词，因为在我们的示例中，每一行只有一个子调用，
    但通常一行代码可能会包含多个子调用，例如 pow(…) + pow(…) + somethingElse(…)。

    因此，更准确地说，执行是“在子调用之后立即恢复”的。


    pow(2, 1)
    重复该过程：在第 5 行生成新的子调用，现在的参数是 x=2, n=1。

    新的执行上下文被创建，前一个被压入堆栈顶部：
        Context: { x: 2, n: 1, at line 1 } call pow(2, 1)
        Context: { x: 2, n: 2, at line 5 } call pow(2, 2)
        Context: { x: 2, n: 3, at line 5 } call pow(2, 3)
    此时，有 2 个旧的上下文和 1 个当前正在运行的 pow(2, 1) 的上下文。

    
    出口
    在执行 pow(2, 1) 时，与之前的不同，条件 n == 1 为真，因此 if 的第一个分支生效：

        function pow(x, n) {
            if (n == 1) {
                return x;
            } else {
                return x * pow(x, n - 1);
            }
        }

    此时不再有更多的嵌套调用，所以函数结束，返回 2。

    函数完成后，就不再需要其执行上下文了，因此它被从内存中移除。前一个上下文恢复到堆栈的顶部：
        Context: { x: 2, n: 2, at line 5 } call pow(2, 2)
        Context: { x: 2, n: 3, at line 5 } call pow(2, 3)

    恢复执行 pow(2, 2)。它拥有子调用 pow(2, 1) 的结果，因此也可以完成 x * pow(x, n - 1) 的执行，并返回 4。

    然后，前一个上下文被恢复：
        Context: { x: 2, n: 3, at line 5 } call pow(2, 3)

    当它结束后，我们得到了结果 pow(2, 3) = 8。

    本示例中的递归深度为：3。

    从上面的插图我们可以看出，递归深度等于堆栈中上下文的最大数量。

    请注意内存要求。上下文占用内存，在我们的示例中，求 n 次方需要存储 n 个上下文，
    以供更小的 n 值进行计算使用。

    而循环算法更节省内存：
        function pow(x, n) {
            let result = 1;

            for (let i = 0; i < n; i++) {
                result *= x;
            }
            return result;
        }

    迭代 pow 的过程中仅使用了一个上下文用于修改 i 和 result。它的内存要求小，并且是固定了，不依赖于 n。

    任何递归都可以用循环来重写。通常循环变体更有效。

    但有时重写很难，尤其是函数根据条件使用不同的子调用，然后合并它们的结果，或者分支比较复杂时。
    而且有些优化可能没有必要，完全不值得。

    递归可以使代码更短，更易于理解和维护。并不是每个地方都需要优化，大多数时候我们需要一个好代码，
    这就是为什么要使用它。



*/




// -------------------------------------------------------------------------------------------




// 递归遍历
    //- 递归的另一个重要应用就是递归遍历。

// 假设我们有一家公司。人员结构可以表示为一个对象：
/*
let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
*/

// 换句话说，一家公司有很多部门。
    // 一个部门可能有一 数组 的员工，比如，sales 部门有 2 名员工：John 和 Alice。
    // 或者，一个部门可能会划分为几个子部门，比如 development 有两个分支：sites 和 internals，它们都有自己的员工。
    // 当一个子部门增长时，它也有可能被拆分成几个子部门（或团队）。
    // 例如，sites 部门在未来可能会分为 siteA 和 siteB。并且，它们可能会被再继续拆分。
    // 现在，如果我们需要一个函数来获取所有薪资的总数。我们该怎么做？




// 我们可以看到，当我们的函数对一个部门求和时，有两种可能的情况：
    //1. 要么是由一 数组 的人组成的“简单”的部门 —— 这样我们就可以通过一个简单的循环来计算薪资的总和。
    //2. 或者它是一个有 N 个子部门的 对象 —— 那么我们可以通过 N 层递归调用来求每一个子部门的薪资，
    //   然后将它们合并起来。

// 第一种情况是由一数组的人组成的部门，这种情况很简单，是最基础的递归。

// 第二种情况是我们得到的是对象。那么可将这个复杂的任务拆分成适用于更小部门的子任务。
// 它们可能会被继续拆分，但很快或者不久就会拆分到第一种情况那样。

// 这个算法从代码来看可能会更简单：
let company = { // 是同一个对象，简洁起见被压缩了
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 1600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// 用来完成任务的函数
function sumSalaries(department) {
  if (Array.isArray(department)) { // 情况（1）
    return department.reduce((prev, current) => prev + current.salary, 0); // 求数组的和
  } else { // 情况（2）
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // 递归调用所有子部门，对结果求和
    }
    return sum;
  }
}
console.log(sumSalaries(company)); // 7700




// -------------------------------------------------------------------------------------------




// 递归结构
    //- 递归（递归定义的）数据结构是一种部分复制自身的结构。
 
// 链表
    //- 想象一下，我们要存储一个有序的对象列表。正常的选择会是一个数组：
    // let arr = [obj1, obj2, obj3];

// 但是用数组有个问题。“删除元素”和“插入元素”的操作代价非常大。
// 例如，arr.unshift(obj) 操作必须对所有元素重新编号以便为新的元素 obj 腾出空间，
// 而且如果数组很大，会很耗时。arr.shift() 同理。

// 唯一对数组结构做修改而不需要大量重排的操作就是对数组末端的操作：
    //- arr.push/pop。因此，对于大队列来说，当我们必须对数组首端的元素进行操作时，数组会很慢。
    // （译注：此处的首端操作其实指的是在尾端以外的数组内的元素进行插入/删除操作。）

// 如果我们确实需要快速插入/删除，则可以选择另一种叫做 链表 的数据结构。

// 链表元素 是一个使用以下元素通过递归定义的对象：
    //- value。
    //- next    属性引用下一个 链表元素 或者代表末尾的 null。

// 例如：
/*
let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
*/

/*

// 一段用来创建链表的代码：
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;

// 这里有很多个对象，每一个都有 value 和指向邻居的 next。变量 list 是链条中的第一个对象，
// 因此顺着 next 指针，我们可以抵达任何元素。

// 该链表可以很容易被拆分为多个部分，然后再重新组装回去：
let secondList = list.next.next;
list.next.next = null;

// 合并：
list.next.next = secondList;

*/

// 当然，我们可以在任何位置插入或移除元素。
// 比如，要添加一个新值，我们需要更新链表的头：
let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// 将新值添加到链表头部
list = { value: "new item", next: list };

// 要从中间删除一个值，可以修改前一个元素的 next：
list.next = list.next.next;
console.log(list.next.value);

// 我们让 list.next 从 1 跳到值 2。现在值 1 就被从链表中移除了。
// 如果它没有被存储在其它任何地方，那么它会被自动从内存中删除。

// 与数组不同，链表没有大规模重排，我们可以很容易地重新排列元素。

// 链表主要的缺点就是我们无法很容易地通过元素的编号获取元素。但在数组中却很容易：arr[n] 是一个直接引用。
// 而在链表中，我们需要从起点元素开始，顺着 next 找 N 次才能获取到第 N 个元素。

// 但是我们也并不是总需要这样的操作。
// 比如，当我们需要一个队列甚至一个 双向队列 —— 有序结构必须可以快速地从两端添加/移除元素，但是不需要访问的元素。




// -------------------------------------------------------------------------------------------



// 对数字求和到给定值

// 编写一个函数 sumTo(n) 计算 1 + 2 + ... + n 的和。
// 举个例子：
    //- sumTo(1) = 1
    //- sumTo(2) = 2 + 1 = 3
    //- sumTo(3) = 3 + 2 + 1 = 6
    //- sumTo(4) = 4 + 3 + 2 + 1 = 10
    //- ...
    //- sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050

// 用三种方式实现：
    //- 使用循环。
    //- 使用递归，对 n > 1 执行 sumTo(n) = n + sumTo(n-1)。
    //- 使用 等差数列 求和公式.

// P.S. 哪种解决方式最快？哪种最慢？为什么？
// P.P.S. 我们可以使用递归来计算 sumTo(100000) 吗？

// 使用循环。
function sumTo1(n) { 
    let sum = 0;
    for (let i = 0; i <= n; i++) {
        sum += i;
    }
    return sum;
}
console.log( "循环: " + sumTo1(100) ); // 5050


// 递归
function sumTo2(n) { 
    if (n == 1) {
        return 1;
    } else {
        return n + sumTo2(n - 1);
    }
}
console.log( "递归: " + sumTo2(100) ); // 5050


// 等差数列 Sn=a1*n+[n*(n-1)*d]/2, a2-a1=d;a3-a2=d;a4-a3=d...an-a(n-1)=d
function sumTo3(n) { 
    return 1 * n + (n * (n - 1) * 1) / 2;
}
console.log( "等差数列: " + sumTo3(100) ); // 5050


// P.S. 当然是公式解法最快。对任何数字 n，只需要进行 3 次运算。

// 循环的速度次之。在循环和递归方法里，我们对相同的数字求和。
// 但是递归涉及嵌套调用和执行堆栈管理。这也会占用资源，因此递归的速度更慢一些。

// P.P.S. 一些引擎支持“尾调用（tail call）”优化：如果递归调用是函数中的最后一个调用（例如上面的 sumTo），
// 那么外部的函数就不再需要恢复执行，因此引擎也就不再需要记住他的执行上下文。这样就减轻了内存负担，
// 因此计算 sumTo(100000) 就变得可能。但是如果你的 JavaScript 引擎不支持尾调用优化，那就会报错：
// 超出最大堆栈深度，因为通常总堆栈的大小是有限制的。





// -------------------------------------------------------------------------------------------



// 计算阶乘

// 自然数的 阶乘 是指，一个数乘以 数字减去 1，然后乘以 数字减去 2，以此类推直到乘以 1。n 的阶乘被记作 n!。

// 我们可以将阶乘的定义写成这样：
    // n! = n * (n - 1) * (n - 2) * ...*1

// 不同 n 的阶乘的值：
    //- 1! = 1
    //- 2! = 2 * 1 = 2
    //- 3! = 3 * 2 * 1 = 6
    //- 4! = 4 * 3 * 2 * 1 = 24
    //- 5! = 5 * 4 * 3 * 2 * 1 = 120

// P.S. 提示：n! 可以被写成 n * (n-1)!，比如 3! = 3*2! = 3*2*1! = 6。


// 任务是编写一个函数 factorial(n) 使用递归调用计算 n!。
console.log( "阶乘: " + factorial(5) ); // 120

function factorial(n) {
    if (n == 1) {
        return 1;
    }
    return n * factorial(n - 1);
}



// -------------------------------------------------------------------------------------------





// 斐波那契数

// 斐波那契数 序列有这样的公式： Fn = Fn-1 + Fn-2。换句话说，下一个数字是前两个数字的和。

// 前两个数字是 1，然后是 2(1+1)，然后 3(1+2)，5(2+3) 等：1, 1, 2, 3, 5, 8, 13, 21...。

// 编写一个函数 fib(n) 返回第 n 个斐波那契数。
function fib(n) { 
    return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

console.log("斐波那契数: " + fib(3)); // 2
console.log("斐波那契数: " + fib(7)); // 13
// console.log("斐波那契数: " + fib(77)); // 5527939700884757






// -------------------------------------------------------------------------------------------





// 输出一个单链表

//假设我们有一个单链表：
list = {
    value: 1,
    next: {
        value: 2,
        next: {
            value: 3,
            next: {
                value: 4,
                next: null
            }
        }
    }
};

// 编写一个可以逐个输出链表元素的函数 printList(list)。

// 使用两种方式实现：循环和递归。

// 哪个更好：用递归还是不用递归的？

// 循环
function printList(list) {
    let tmp = list;
  
    while (tmp) {
      console.log(tmp.value);
      tmp = tmp.next;
    }
}
printList(list);


function printList1(list) {
    let temp;
    do {
        temp = list;
        console.log( "循环: " + temp?.value );
        list = temp?.next;
    } while (temp);
    // 循环: 1
    // 循环: 2
    // 循环: 3
    // 循环: 4
    // 循环: undefined
}
printList1(list);



// 递归
function printList2(list) {
    console.log("递归: " + list.value);
    if (list.next) {
        printList2(list.next);
    }
}
printList2(list);




// -------------------------------------------------------------------------------------------



// 反向输出单链表

// 反向输出前一个任务 输出一个单链表 中的单链表。

// 使用两种解法：循环和递归。


// 循环
function printReverseList1(list) {
    let arr = [];
    let tmp = list;
  
    while (tmp) {
      arr.push(tmp.value);
      tmp = tmp.next;
    }
  
    for (let i = arr.length - 1; i >= 0; i--) {
        console.log( arr[i] );
    }
}
printReverseList1(list);


// 递归
function printReverseList(list) {

    if (list.next) {
      printReverseList(list.next);
    }
  
    console.log(list.value);
}

printReverseList(list);